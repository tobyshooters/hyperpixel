<style>
body {
    margin: 20px 40px;
}
#container {
    position: relative;
    width: 100%;
    height: auto;
}
img {
    width: 100%;
    height: auto;
    object-fit: contain;
    border: 1px solid black;
}
.bbox-creation {
    position: absolute;
    background: rgba(0, 155, 255, 0.5);
}
.bbox-creation > * {
    display: none;
}
.bbox {
    position: absolute;
    background: none;
    border: 1px dashed dodgerblue;
}
.bbox > * {
    display: none;
}
.bbox:hover > * {
    display: block;
}
#input {
  width: 85px;
  color: transparent;
  padding: 2px;
}
</style>

<a href="/">hyperpixel</a>
<div id="home" style="display: flex; flex-direction: column">
    <div style="display: flex; align-items: center">
        <p style="margin-right: 11px">/{{imageId}}</p>
        <input id="input" type="file" accept="image/*"/>
        <button id="delete">Delete</button>
    </div>
    <div id="container">
        <img id="image"></img>
    </div>
    <div id="backlinks" style="margin-top: 11px">
    </div>
    <code id="text" style="margin-top: 11px">
    </code>
</div>

<script>
    class Annotation {
        constructor(id, imageId, entry, sw, sh ) {
            this.id = id;
            this.imageId = imageId;

            const { x, y, w, h, href } = entry;

            this.bbox = document.createElement("a");
            this.setPos(x, y);
            this.setSize(w, h);
            this.setAnchor(sw, sh);

            this.bbox.addEventListener("click", e => {
                e.stopPropagation();
                if (e.shiftKey) {
                    e.preventDefault();
                    this.bbox.remove();

                    fetch(`/${this.imageId}/${this.id}`, {
                        method: "POST",
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(null),
                    })
                }
            })
            this.bbox.addEventListener("mousedown", e => e.stopPropagation());

            this.linkInput = document.createElement("input");
            this.linkInput.type = "text";
            this.linkInput.style.width = "100%";
            this.linkInput.addEventListener("change", e => {
                if (e.target.value[0] == "/") {
                    // Internal link
                    this.setHref(e.target.value);
                } else {
                    // External link
                    const parts = e.target.value.match(/(https?:\/\/)(.*)/)
                    const href = parts ? parts[0] : "https://" + e.target.value;
                    this.setHref(href);
                }

                fetch(`/${this.imageId}/${this.id}`, {
                    method: "POST",
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(this.getEntry())
                })
            });
            this.linkInput.addEventListener("click", e => e.preventDefault());
            this.linkInput.addEventListener("mouseup", e => e.stopPropagation());
            this.linkInput.addEventListener("mousedown", e => e.stopPropagation());
            this.bbox.appendChild(this.linkInput);

            this.setHref(href);
        }

        getEntry() {
          return {
            x: this.x, 
            y: this.y, 
            w: this.w, 
            h: this.h, 
            href: this.href,
          }
        }

        setAnchor(sw, sh) {
            this.sw = sw;
            this.sh = sh;
            this.setPos(this.x, this.y);
            this.setSize(this.w, this.h);
        }

        setPos(x, y) {
            this.x = x;
            this.y = y;
            this.bbox.style.left = (this.x * this.sw) + "px";
            this.bbox.style.top = (this.y * this.sh) + "px";
        }

        setSize(w, h) {
            this.w = w;
            this.h = h;
            this.bbox.style.width = (this.w * this.sw) + "px";
            this.bbox.style.height = (this.h * this.sh) + "px";
        }

        setHref(href) {
            this.href = href;
            this.bbox.href = href;
            this.linkInput.value = href;
        }

        delete() {
          this.linkInput.remove();
          this.bbox.remove();
        }
    }
</script>

<script>
    // Extract out Jinja variables
    const imageId = "{{imageId}}"
    const data = {{data | tojson}};

    // References to dom
    const container = document.getElementById("container");
    const image = document.getElementById("image");

    // Reference to all annotations
    let notes = [];

    const loadImage = (blob) => {
        // Clear annotations; They'll be re-rendered
        notes.forEach(n => n.delete());
        notes = [];

        // Immediately show image on front-end
        const fr = new FileReader();
        fr.onload = () => {
          image.src = fr.result;
        }
        fr.readAsDataURL(blob);

        // Persist to back-end so shows up on reload
        const form = new FormData();
        form.append('file', blob);
        fetch(`/${imageId}`, {
            method: "POST",
            body: form,
        })
    }

    const renderAnnotations = (annotations) => {
        const r = container.getBoundingClientRect();
        for (const [id, entry] of Object.entries(annotations)) {
            const note = new Annotation(id, imageId, entry, r.width, r.height);
            note.bbox.classList.add("bbox");
            container.appendChild(note.bbox);
            notes.push(note);
        }
    }
    
    // Handle resizes
    window.addEventListener("resize", () => {
        const r = container.getBoundingClientRect();
        notes.forEach(n => n.setAnchor(r.width, r.height));
    })

    // Allow uploading the image through input
    const input = document.getElementById("input");
    input.onchange = e => {
      loadImage(e.target.files[0]);
    }

    // Allow deleting the image
    const del = document.getElementById("delete");
    del.onclick = async () => {
        await fetch(`/${imageId}`, { method: "DELETE" });
        window.location = "/";
    }

    // Allow dropping onto container
    container.addEventListener("dragenter", e => {
        e.preventDefault();
        image.style.opacity = 0.5;
    });
    container.addEventListener("dragover", e => {
        e.preventDefault();
    });
    container.addEventListener("dragleave", e => {
        e.preventDefault();
        image.style.opacity = 1.0;
    });
    container.addEventListener("drop", e => {
        e.preventDefault();
        image.style.opacity = 1.0;
        loadImage(e.dataTransfer.files[0])
    });

    // Annotation creation via mouse-drag
    const existingIds = Object.keys(data.annotations || {}).map(k => parseInt(k));
    let nextId = existingIds.length ?  Math.max(...existingIds) : 0;

    const annotate = e => {
        e.preventDefault();
        e.stopPropagation();

        nextId += 1;
        const r = e.target.getBoundingClientRect();
        const x = (e.clientX - r.left) / r.width;
        const y = (e.clientY - r.top) / r.height;

        const entry = {x, y, w: 0, h: 0, href: ""}
        const note = new Annotation(nextId, imageId, entry, r.width, r.height);
        note.bbox.classList.add("bbox-creation");
        container.appendChild(note.bbox);
        notes.push(note);

        const mousemove = e => {
            const r = e.target.getBoundingClientRect();
            note.setSize(
                (e.clientX - r.left) / r.width - note.x, 
                (e.clientY - r.top) / r.height - note.y
            );
        }

        const mouseup = e => {
            if (note.w < 0.05 && note.h < 0.05) {
                // Ignore bboxes smaller than 5% of image
                note.bbox.remove();
            } else {
                note.bbox.classList.remove("bbox-creation");
                note.bbox.classList.add("bbox");
            }
            document.removeEventListener('mousemove', mousemove);
            document.removeEventListener('mouseup', mouseup);
        }
        document.addEventListener("mousemove", mousemove);
        document.addEventListener("mouseup", mouseup);
    }

    container.addEventListener("mousedown", annotate);

    if (Object.keys(data).length) {
        image.onload = () => {
            // Draw annotations
            renderAnnotations(data.annotations);

            // Add backlinks
            const backlinkArea = document.getElementById("backlinks");
            for (const imageId of data.backlinks) {
                const backlink = document.createElement("a");
                backlink.innerHTML = `/${imageId}`;
                backlink.href = `/${imageId}`;
                backlink.style.marginRight = "11px";
                backlinkArea.appendChild(backlink);
            }

            // Add text
            const text = document.getElementById("text");
            text.innerHTML = data["text"];
        }
        // Load image from source
        image.src = "files/" + data.path;
    }
</script>

