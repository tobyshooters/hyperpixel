<meta charset="UTF-8">

<style>
body {
    margin: 20px 40px;
}
#container {
    position: relative;
    width: 100%;
    height: auto;
}
#image {
    width: 100%;
    height: auto;
    object-fit: contain;
    border: 1px solid black;
}
#container:hover > .bbox {
    border: 1px dashed dodgerblue;
}
.bbox-creation {
    position: absolute;
    background: rgba(0, 155, 255, 0.5);
}
.bbox-creation > * {
    display: none;
}
.bbox {
    position: absolute;
    background: none;
    border: 1px dashed black;
}
.bbox > * {
    display: none;
}
.bbox:hover > * {
    display: block;
}
#header {
  display: flex;
  align-items: center;
  margin: 10px 0px 20px 0px;
}
#rename {
  border: 1px solid black;
  padding: 5px;
  margin: 0px 10px 0px 0px;
}
#file {
  width: 85px;
  color: transparent;
  padding: 2px;
}
</style>

<a href="/">hyperpixel</a>
<div id="home" style="display: flex; flex-direction: column">
    <div id="header">
        <input id="rename" type="text" value="/" placeholder="Insert name"></input>
        <input id="file" type="file" accept="image/*"/>
        <button id="delete">Delete</button>
    </div>
    <div id="container">
        <img id="image"></img>
    </div>
    <div id="backlinks" style="margin-top: 11px">
    </div>
    <code id="text" style="margin-top: 11px">
    </code>
</div>

<script>
    class Annotation {
      constructor(id, imageId, entry, sw, sh ) {
        this.id = id;
        this.imageId = imageId;

        const { x, y, w, h, to } = entry;

        this.bbox = document.createElement("a");
        this.setPos(x, y);
        this.setSize(w, h);
        this.setAnchor(sw, sh);

        this.bbox.addEventListener("click", e => {
          e.stopPropagation();
          if (e.shiftKey) {
            e.preventDefault();
            if (this.to) {
              send({
                op: "DELETE",
                path: ["annotations", this.id],
              })
            }
            this.bbox.remove();
          }
        })
        this.bbox.addEventListener("mousedown", e => e.stopPropagation());

        this.linkInput = document.createElement("input");
        this.linkInput.type = "text";
        this.linkInput.style.width = "100%";
        this.linkInput.addEventListener("change", e => {
          const isInternal = e.target.value[0] === "/";

          if (isInternal) {
            this.setTo(e.target.value.slice(1));
          } else {
            const parts = e.target.value.match(/(https?:\/\/)(.*)/)
            const href = parts ? parts[0] : "https://" + e.target.value;
            this.setTo(href);
          }

          send({
            op: "PUT",
            path: ["annotations", this.id],
            data: {
              type: isInternal ? "internal" : "external",
              from: this.imageId,
              to: this.to,
              x: this.x,
              y: this.y,
              w: this.w,
              h: this.h
            }
          })
        });

        this.linkInput.addEventListener("click", e => e.preventDefault());
        this.linkInput.addEventListener("mouseup", e => e.stopPropagation());
        this.linkInput.addEventListener("mousedown", e => e.stopPropagation());
        this.bbox.appendChild(this.linkInput);

        this.setTo(to || "");

        if (this.to in db["images"]) {
          this.preview = document.createElement("img");
          this.preview.src = "/files/" + db["images"][this.to]["path"];
          this.preview.style.position = "absolute";
          this.preview.style.x = 0;
          this.preview.style.y = 0;
          this.preview.style.width = this.w * this.sw;
          this.preview.style.height = this.h * this.sh - 24;
          this.preview.style.objectFit = "cover";
          this.bbox.appendChild(this.preview);
        }
      }

      setAnchor(sw, sh) {
        this.sw = sw;
        this.sh = sh;
        this.setPos(this.x, this.y);
        this.setSize(this.w, this.h);
      }

      setPos(x, y) {
        this.x = x;
        this.y = y;
        this.bbox.style.left = (this.x * this.sw) + "px";
        this.bbox.style.top = (this.y * this.sh) + "px";
      }

      setSize(w, h) {
        this.w = w;
        this.h = h;
        this.bbox.style.width = (this.w * this.sw) + "px";
        this.bbox.style.height = (this.h * this.sh) + "px";
      }

      setTo(to) {
        this.to = to;
        if (to.startsWith('http')) {
          this.bbox.href = to;
        } else {
          this.bbox.href = "./" + to;
        }
        this.linkInput.value = to;
      }

      delete() {
        this.linkInput.remove();
        this.bbox.remove();
      }
    }
</script>

<script>
    // Reactive data
    const imageId = window.location.pathname.slice(1);
    let db = {}
    let data = {};
    let annotations = {};
    let backlinks = [];

    const ws = new WebSocket("ws://localhost:5000/ws")
    const send = (msg) => ws.send(JSON.stringify(msg));

    ws.onopen = () => {
      send({op: "SUBSCRIBE", path: []});
    }
    
    ws.onmessage = (e) => {
      db = JSON.parse(e.data);
      data = db["images"][imageId];
      annotations = {};
      backlinnks = [];

      for (const [a_id, annotation] of Object.entries(db["annotations"])) {
        if (annotation["from"] == imageId) {
          annotations[a_id] = annotation;
        }
        if (annotation["to"] == imageId) {
          backlinks.push(annotation["from"]);
        }
      }

      render();
    }

    // References to dom
    const container = document.getElementById("container");
    const image = document.getElementById("image");

    let notes = [];
      
    // Resize annotations on window resize
    window.addEventListener("resize", () => {
      const r = container.getBoundingClientRect();
      notes.forEach(n => n.setAnchor(r.width, r.height));
    })

    // Annotation creation via mouse-drag
    container.addEventListener("mousedown", e => {
      e.preventDefault();
      e.stopPropagation();

      const ks = Object.keys(annotations).map(k => parseInt(k));
      let nextId = (Math.max(...ks) + 1).toString();

      const r = e.target.getBoundingClientRect();
      const x = (e.clientX - r.left) / r.width;
      const y = (e.clientY - r.top) / r.height;

      const entry = {x, y, w: 0, h: 0, href: ""}
      const note = new Annotation(nextId, imageId, entry, r.width, r.height);
      note.bbox.classList.add("bbox-creation");
      container.appendChild(note.bbox);
      notes.push(note);

      const mousemove = e => {
        const r = e.target.getBoundingClientRect();
        note.setSize(
          (e.clientX - r.left) / r.width - note.x, 
          (e.clientY - r.top) / r.height - note.y
        );
      }

      const mouseup = e => {
        if (note.w < 0.05 && note.h < 0.05) {
          // Ignore bboxes smaller than 5% of image
          note.bbox.remove();
        } else {
          note.bbox.classList.remove("bbox-creation");
          note.bbox.classList.add("bbox");
        }
        document.removeEventListener('mousemove', mousemove);
        document.removeEventListener('mouseup', mouseup);
      }

      document.addEventListener("mousemove", mousemove);
      document.addEventListener("mouseup", mouseup);
    });

    // Renaming annnotation is persisted
    const rename = document.getElementById("rename");
    rename.value = imageId;
    rename.onchange = e => {
      send({
        op: "RENAME",
        path: ["images", imageId],
        data: e.target.value
      })
    }

    // Allow uploading the image through input or drop
    const saveImage = (blob) => {
      const fr = new FileReader();
      fr.onload = () => {
        image.src = fr.result;
      }
      fr.readAsDataURL(blob);

      const form = new FormData();
      form.append('file', blob);
      form.append('image_id', imageId);
      fetch("/upload", {
        method: "POST",
        body: form,
      })
    }

    const filepicker = document.getElementById("file");
    filepicker.onchange = e => {
      saveImage(e.target.files[0]);
    }

    container.addEventListener("dragenter", e => {
        e.preventDefault();
        image.style.opacity = 0.5;
    });
    container.addEventListener("dragover", e => {
        e.preventDefault();
    });
    container.addEventListener("dragleave", e => {
        e.preventDefault();
        image.style.opacity = 1.0;
    });
    container.addEventListener("drop", e => {
        e.preventDefault();
        image.style.opacity = 1.0;
        saveImage(e.dataTransfer.files[0])
    });

    // Allow deleting the image
    const del = document.getElementById("delete");
    del.onclick = async () => {
      send({
        op: "DELETE",
        path: ["images", imageId],
      })
      window.location = "/";
    }

    // Render cycle called when ever there is new data
    const render = () => {
      if (data) {
        image.onload = () => {
          // Clear annotations
          notes.forEach(n => n.delete());
          notes = [];

          // Draw annotations
          const r = container.getBoundingClientRect();
          for (const [a_id, annotation] of Object.entries(annotations)) {
            const note = new Annotation(a_id, imageId, annotation, r.width, r.height);
            note.bbox.classList.add("bbox");
            container.appendChild(note.bbox);
            notes.push(note);
          }

          // Add backlinks
          const backlinkArea = document.getElementById("backlinks");
          for (const imageId of backlinks) {
            const backlink = document.createElement("a");
            backlink.innerHTML = `/${imageId}`;
            backlink.href = `/${imageId}`;
            backlink.style.marginRight = "11px";
            backlinkArea.appendChild(backlink);
          }

          // Add text
          const text = document.getElementById("text");
          text.innerHTML = data["text"];
        }

        const path = data["path"];
        image.src = `/files/${path}`;
      }
    }
</script>

